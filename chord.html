<style>

.subchart-line {
  fill: none;
  stroke-width: 2px;
}

.group-tick line {
    stroke: #000;
}

.group-tick-label {
    font: 10px sans-serif;
}

.ribbons {
    fill-opacity: 0.67;
}

.chord-label {
    font: 10px sans-serif;
    font-weight: bold;
}

div.tooltip {
    position: absolute;
    text-align: left;
    /* width: 60px;
    height: 28px; */
    padding: 3px;
    font: 12px sans-serif;
    background: rgba(200, 200, 200, 0.6);
    border: 0px;
    border-radius: 2px;
    pointer-events: none;
}

.hidden {
    display: none;
}

#graphsContainer {
    display: block;
    clear: both;
}

#graphsContainer #depwheel {
    float: left;
    padding: 10px;
    /*border: 3px solid green;*/
}

#graphsContainer #subchart {
    float: left;
    padding: 10px;
    /*border: 3px solid green;*/
}

#subchart .grid line {
    stroke: lightgrey;
    opacity: 0.7;
}

#subchart .legend {
    background: rgba(200, 200, 200, 0.6);
    opacity: 0.7;
}

</style>

<script src="https://d3js.org/d3.v4.js"></script>
<script src="d3.legend.js"></script>
<script src="https://cdn.jsdelivr.net/lodash/4.16.4/lodash.js"></script>

<script src="https://code.jquery.com/jquery-2.2.4.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.15.2/moment.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.11/c3.css" />

Hover mouse on elements for interaction.
<div id="graphsContainer">
    <div id="depwheel"></div>
    <div id="subchart"></div>
</div>

<script>

// https://jsfiddle.net/az73q6jm/
// http://jsfiddle.net/az73q6jm/embedded/result/

var   dims = ['client', 'cloud_provider'];
var totals = ['cost'];
var scoreField = totals[0];

function otherThanDim(dim) {
    return dims[0] === dim ? dims[1] : dims[0];
}

// generate timeseries
function distOnTimestamps(businessData, monthsCount) {
    var newBD = [];

    businessData.forEach(function(row) {
        var initialMonth = moment("2016/01/01", "YYYY/MM/DD");
        var initialAvg = row[scoreField] / monthsCount;
        var curMonth = initialMonth;
        var curAvg   = initialAvg;
        for(var i = 0; i < monthsCount; i++) {
            var newRow = _.cloneDeep(row);
            newRow[scoreField] = Math.round(curAvg);
            newRow.timestamp = curMonth.toDate();
            newBD.push(newRow);

            curAvg = curAvg + (Math.random() * 0.2 - 0.1) * initialAvg;
            curMonth = curMonth.add(1, 'month');
        }
    });

    return newBD;
}

var businessData = [
    { client: 'clientA', cloud_provider: 'Azure',     cost:  1000 },
    { client: 'clientA', cloud_provider: 'AWS',       cost: 40000 },
    { client: 'clientA', cloud_provider: 'Google',    cost: 10000 },
    { client: 'clientA', cloud_provider: 'OpenStack', cost: 15000 },

    { client: 'clientB', cloud_provider: 'Azure',     cost:  5000 },
    { client: 'clientB', cloud_provider: 'AWS',       cost:  2000 },
    { client: 'clientB', cloud_provider: 'Google',    cost:  3000 },
    { client: 'clientB', cloud_provider: 'OpenStack', cost: 20000 },

    { client: 'clientC', cloud_provider: 'Azure',     cost: 50000 },
    { client: 'clientC', cloud_provider: 'AWS',       cost: 20000 },
    { client: 'clientC', cloud_provider: 'Google',    cost: 30000 },
    { client: 'clientC', cloud_provider: 'OpenStack', cost:  2000 },
];

businessData = distOnTimestamps(businessData, 12);

function prepareChordsData(businessData) {
    var idx = [];

    dims.forEach(function(dim) {
        var reducerF = function(accum, elem) {
            var addressedElem = { dim: dim, elem: elem[dim], total: elem[scoreField] };
            var foundIdx = _.findIndex(idx, function(checkedElem) {
                var eq = true;
                eq = eq && (addressedElem.dim  === checkedElem.dim);
                eq = eq && (addressedElem.elem === checkedElem.elem);
                return eq;
            });

            if(foundIdx === -1) {
                addressedElem.index = idx.length;
                idx.push(addressedElem);
            } else {
                idx[foundIdx].total += addressedElem.total;
            }
        }
        _.reduce(businessData, reducerF, idx);
    });

    var matrix = [];

    _.forEach(idx, function(addressedElemX) {
        var matrixRow = [];
        _.forEach(idx, function(addressedElemY) {
            if(dims.indexOf(addressedElemX.dim) === dims.indexOf(addressedElemY.dim)) {
                matrixRow.push(0);
            } else {
                var relevantBD = _.filter(businessData, function(elem) {
                        var eq = true;
                        eq = eq && (elem[addressedElemX.dim] === addressedElemX.elem);
                        eq = eq && (elem[addressedElemY.dim] === addressedElemY.elem);
                        return eq;
                    })
                function reducer(accum, elem) { return accum + elem[scoreField]; }
                var sum = _.reduce(relevantBD, reducer, 0);
                matrixRow.push(sum);
            }
        });

        matrix.push(matrixRow);
    });

    return {
        idx: idx,
        matrix: matrix
    }
}

var chordData = prepareChordsData(businessData);
console.log(chordData);


var subChartProto = {
    bindto: '#subchart',
    data: {
        x: 'Period Month', // to be replaced, when applying this configuration
        y: 'AWS',          // to be replaced, when applying this configuration (not a c3 parameter)
        columns: [         // to be replaced, when applying this configuration
            ['Period Month', '2016/01', '2016/02', '2016/03', '2016/04', '2016/05', '2016/06', '2016/07', '2016/08', '2016/09', '2016/10', '2016/11', '2016/12'],
            ['AWS', 200, 1000, 14000, 200, 200000, 100000, 90000, 100000, 140000, 20000, 10000, 40000],
            ['Azure', 300, 1500, 1400, 20000, 10000, 4000, 9000, 1000, 1400, 2000, 1000, 400],
            ['Google', 3000, 15000, 10000, 50000, 80000, 70000, 9000, 10000, 14000, 12000, 8000, 4000],
        ],
        columnsRaw : [     // to be replaced, when applying this configuration (not a c3 parameter)
            [ // line
                {}, // rows
                {},
                {},
            ],
            [ // line
                {}, // rows
                {},
                {},
            ],
            [ // line
                {}, // rows
                {},
                {},
            ],
        ],
        type: 'line'
    },
    grid: {
        x: {
            show: true
        },
        y: {
            show: true
        }
    },
    axis: {
        x: {
            label: {
                text: 'Name Of X Axis', // to be replaced, when applying this configuration
            },
            type: 'category',
            tick: {
                rotate: 90,
                multiline: false
            }
        },
        y: {
            label: {
                text: 'Name Of Y Axis', // to be replaced, when applying this configuration
                position: 'outer-middle',
            },
            tick: {
                format: d3.format('$,'),
                //or format: function (d) { return '$' + d; }

            }
        }
    }
};

function prepareSubChartColumns(businessData, dim1Elem, dim2Elem, partitionByDim2, scoreColId) {
    var chartColumns = [];
    var relevantData = _.filter(businessData, function(row) {
        var isRelevant = true;
        isRelevant = isRelevant && row[dim1Elem.dim] === dim1Elem.elem;
        if(!_.isUndefined(dim2Elem))
            isRelevant = isRelevant && row[dim2Elem.dim] === dim2Elem.elem;
        return isRelevant;
    });

    // if multiple charts
    if(_.isUndefined(dim2Elem)) {
        relevantData = _.values(_.groupBy(relevantData, partitionByDim2));
    } else { // only one line
        relevantData = [relevantData];
    }

    var xAxis = ['timestamp'];
    _.forEach(relevantData[0], function(row) {
        xAxis.push(row['timestamp']);
    });
    chartColumns.push(xAxis);

    _.forEach(relevantData, function(line) {
        var dataCol = [scoreColId];
        _.forEach(relevantData, function(row) {
            dataCol.push(row[scoreColId]);
        });

        chartColumns.push(dataCol);
    });

    return {
        c3: chartColumns,
        raw: relevantData,
    };
}

var subChartInstance = undefined;
function applySubChart(title, nameOfX, nameOfY, chartColumns, xColumnId, yColumnId, partitionDim) {
    if(!_.isUndefined(subChartInstance)) {
        subChartInstance.destroy();
    }

    var cfg = _.cloneDeep(subChartProto);

    cfg.axis.x.label.text = nameOfX;
    cfg.axis.y.label.text = nameOfY;
    cfg.data.x = xColumnId;
    cfg.data.y = yColumnId;
    cfg.data.columns    = chartColumns.c3;
    cfg.data.columnsRaw = chartColumns.raw;
    cfg.data.partitionDim = partitionDim;

    subChartInstance = drawChart(cfg);

    d3.select(subChartProto.bindto + ' svg').append("text")
        .attr("x", 30)
        .attr("y", 30)
        .style("text-anchor", "left")
        .text(title);
}

function drawChart(cfg) {
    console.log(cfg.data.columnsRaw);
    var data = _.cloneDeep(cfg.data.columnsRaw);
    // set the dimensions and margins of the graph
    var margin = {
            top: 60,
            right: 20,
            bottom: 60,
            left: 80
        },
        width = 450,
        height = 450;

    // set the ranges
    var x = d3.scaleTime()  .range([0, width]);
    var y = d3.scaleLinear().range([height, 0]);

    // define the line
    var valueline = d3.line()
        .x(function(d) {
            return x(d[cfg.data.x]);
        })
        .y(function(d) {
            return y(d[cfg.data.y]);
        });

    // append the svg obgect to the body of the page
    // appends a 'group' element to 'svg'
    // moves the 'group' element to the top left margin
    d3.select(cfg.bindto + ' > *').remove();
    var svg = d3.select(cfg.bindto).append("svg")
        .attr("width",  width  + margin.left + margin.right)
        .attr("height", height + margin.top  + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Scale the range of the data
    x.domain(d3.extent(_.flatten(data), function(d) {
        return d[cfg.data.x];
    }));

    var maxY = d3.max(_.flatten(data), function(d) {
        return d[cfg.data.y];
    });
    maxY = maxY * 1.1;
    y.domain([0, maxY]);

    // Add the X Axis
    svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .attr('class', 'grid')
        .call(d3.axisBottom(x)
            .tickFormat(d3.timeFormat("%Y %b"))
            .tickSize(-height)
        )
        .selectAll("text")
            .attr("transform", "rotate(90)")
            .style("text-anchor", "start")
            .attr("y", 0)
            .attr("x", 9)
            .attr("dy", ".35em")

        ;

    // Add the Y Axis
    svg.append("g")
        .attr('class', 'grid')
        .call(d3.axisLeft(y)
            .tickSize(-width)
        );


    _.forEach(data, function(lineData, i) {
        // Add the valueline path.
        svg.append("path")
            .data([lineData])
            .attr("class", "subchart-line")
            .attr("data-legend", function(d) { return cfg.data.partitionDim ? d[0][cfg.data.partitionDim] : '' })
            .attr('stroke', colorVals[i])
            .attr("d", valueline)
            .attr("fill", "none");
    });

    if(cfg.data.partitionDim) {
        svg.append("g")
            .attr("class","legend")
            .attr("transform","translate(250,-50)")
            .style("font-size","12px")
            .call(d3.legend)
    }

}

var WIDTH = 700;
var HEIGHT = WIDTH;

var container = d3.select("#depwheel");
var outerRadius = Math.min(WIDTH, HEIGHT) * 0.5 - 100;
var innerRadius = outerRadius - 30;

var formatValue = d3.formatPrefix(",.0", 1e3);

var divTooltip = d3.select("body").append("div")
    .attr("class", "tooltip hidden")
    ;

var chord = d3.chord()
    .padAngle(0.03)
    .sortSubgroups(d3.descending);

var arc = d3.arc()
    .innerRadius(innerRadius)
    .outerRadius(outerRadius);

var ribbon = d3.ribbon()
    .radius(innerRadius);

var colorVals =
    [ "#e69373", "#805240", "#e6d5cf", "#bf5830"
    , "#77d36a", "#488040", "#d2e6cf", "#43bf30"
    , "#557aaa", "#405c80", "#cfd9e6", "#306ebf"
    ];

var color = d3.scaleOrdinal()
    .domain(d3.range(colorVals.length))
    .range(colorVals);

var svg = container
    .append("svg")
    .attr("width", WIDTH)
    .attr("height", HEIGHT);

var g = svg
    .append("g")
    .attr("transform", "translate(" + WIDTH / 2 + "," + HEIGHT / 2 + ")")
    .datum(chord(chordData.matrix));

// ribbons
g.append("g")
    .attr("class", "ribbons")
    .selectAll("path")
    .data(function(chords) { return chords; })
    .enter().append("path")
    .attr("class", "ribbon")
    .attr("d", ribbon)
    .style("fill", function(d) { return color(d.source.index); })
    .style("stroke", function(d) { return d3.rgb(color(d.source.index)).darker(); })
    .on("mouseover", mouseHandler(true))
    .on("mouseout",  mouseHandler(false))
    ;

// arcs
var group = g.append("g")
    .attr("class", "groups")
    .selectAll("g")
    .data(function(chords) { return chords.groups; })
    .enter()
    .append("g")
    .attr("class", "group");

group.append("path")
    .style("fill", function(d) { return color(d.index); })
    .style("stroke", function(d) { return d3.rgb(color(d.index)).darker(); })
    .attr("d", arc)
    .on("mouseover", mouseHandler(true))
    .on("mouseout",  mouseHandler(false));
    ;

// Returns an array of tick angles and values for a given group and step.
var TICK_ANGLE = 2 * Math.PI / 120;
function groupTicks(d) {
    var k = d.endAngle - d.startAngle;
    if(k < TICK_ANGLE * 2) return [];
    else return d3.range(0, k, TICK_ANGLE).map(function(tickDAngle, i) {
        return {idx: i, value: tickDAngle * d.value / k, angle: d.startAngle + tickDAngle};
    });
}

var groupTick = group.selectAll(".group-tick")
    .data(groupTicks)
    .enter().append("g")
    .attr("class", "group-tick")
    .attr("transform", function(d) { return "rotate(" + (d.angle * 180 / Math.PI - 90) + ") translate(" + outerRadius + ",0)"; });

groupTick.append("line")
    .attr("x2", 6);

groupTick
    .filter(function(d) { return d.idx % 5 === 0; })
    .append("text")
    .attr("x", 8)
    .attr("dy", ".35em")
    .attr("class", "group-tick-label")
    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180) translate(-16)" : null; })
    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
    .text(function(d) { return formatValue(d.value); });

group.append("svg:text")
    .each(function(d) { d.angle = (d.startAngle + d.endAngle) / 2; })
    .attr("dy", ".35em")
    .attr("class", "chord-label")
    .attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
    .attr("transform", function(d) {
        return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" +
            "translate(" + (outerRadius + 35) + ")" +
            (d.angle > Math.PI ? "rotate(180)" : "");
    })
    .style("cursor", "pointer")
    .text(function(d) { return chordData.idx[d.index].elem; })
    .on("mouseover", mouseHandler(true))
    .on("mouseout",  mouseHandler(false));


// Returns an event handler for fading a given chord group.
function mouseHandler(isFocus) {
    var opacityOfUnrelated = isFocus ? 0.1 : 1

    function mouseHandlerGeneric(data, i) {
        var isRibbon = _.has(data, 'source') && _.has(data, 'target');
        if(isRibbon) {
                    tooltip_forRibbon(data, i);
                       fade_forRibbon(data, i);
            toggleHistogram_forRibbon(data, i);
        } else {
                    tooltip_forArc(data, i);
                       fade_forArc(data, i);
            toggleHistogram_forArc(data, i);
        }
    }

    function tooltip_forRibbon(d, i) {
        var sourceElem = chordData.idx[d.source.index];
        var targetElem = chordData.idx[d.target.index];
        var sourceElemStr = sourceElem.dim + ': ' + sourceElem.elem;
        var targetElemStr = targetElem.dim + ': ' + targetElem.elem;
        var      totalStr =     scoreField + ': ' + chordData.matrix[d.source.index][d.target.index];
        var tooltipHtml = sourceElemStr + '<br/>' + targetElemStr + '<br/>' + totalStr;

        var clazz = 'tooltip';
        if(!isFocus) clazz += ' hidden';

        divTooltip.transition()
            .duration(50)
            .attr('class', clazz);
        divTooltip	.html(tooltipHtml)
            .style("left", (d3.event.pageX)      + "px")
            .style("top",  (d3.event.pageY - 28) + "px");
    }

    function tooltip_forArc(d, i) {
        var  elem    = chordData.idx[d.index];
        var  elemStr = elem.dim + ': ' + elem.elem;
        var totalStr =     scoreField + ': ' + elem.total;
        var tooltipHtml = elemStr + '<br/>' + totalStr;

        var clazz = 'tooltip';
        if(!isFocus) clazz += ' hidden';

        divTooltip.transition()
            .duration(50)
            .attr('class', clazz);
        divTooltip	.html(tooltipHtml)
            .style("left", (d3.event.pageX)      + "px")
            .style("top",  (d3.event.pageY - 28) + "px");
    }


    function fade_forRibbon(ribbon, i) {
        //debugger;

        // fade unrelated ribbons
        svg.selectAll(".ribbon")
            .filter(function(d) {
                return d.source.index !== ribbon.source.index || d.target.index != ribbon.target.index;
            })
            .transition()
            .style("opacity", opacityOfUnrelated);

        // fade arcs, which are not among related
        svg.selectAll('.group')
            .filter(function(d) {
                if(ribbon.source.index === d.index || ribbon.target.index === d.index) return false;
                else return true;
            })
            .transition()
            .style("opacity", opacityOfUnrelated);
    }

    function fade_forArc(g, i) {
        //debugger;
        // fade unrelated ribbons
        svg.selectAll(".ribbon")
            .filter(function(d) {
                return d.source.index != i && d.target.index != i;
            })
            .transition()
            .style("opacity", opacityOfUnrelated);

        var groups = [];

        // get related arcs
        svg.selectAll(".ribbon")
            .filter(function(d) {
                if (d.source.index == i) {
                    groups.push(d.target.index);
                }
                if (d.target.index == i) {
                    groups.push(d.source.index);
                }
            });

        groups.push(i);

        var length = groups.length;

        // fade arcs, which are not among related
        svg.selectAll('.group')
            .filter(function(d) {
                for (var i = 0; i < length; i++) {
                    if(groups[i] == d.index ) return false;
                }
                return true;
            })
            .transition()
            .style("opacity", opacityOfUnrelated);
    };

    function toggleHistogram_forRibbon(data, i) {
        var sourceElem = chordData.idx[data.source.index];
        var targetElem = chordData.idx[data.target.index];
        var partitionDim = undefined;

        var subChartColumns = prepareSubChartColumns(businessData, sourceElem, targetElem, undefined, scoreField);
        applySubChart(sourceElem.elem + ' > ' + targetElem.elem, 'timestamp', scoreField, subChartColumns, 'timestamp', scoreField, partitionDim);
    }
    function toggleHistogram_forArc(data, i) {
        var elem = chordData.idx[data.index];
        var partitionDim = otherThanDim(elem.dim);

        var subChartColumns = prepareSubChartColumns(businessData, elem, undefined, partitionDim, scoreField);
        applySubChart(elem.elem, 'timestamp', scoreField, subChartColumns, 'timestamp', scoreField, partitionDim);
    }

    return mouseHandlerGeneric;
};

</script>
